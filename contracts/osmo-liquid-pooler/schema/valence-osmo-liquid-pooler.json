{
  "contract_name": "valence-osmo-liquid-pooler",
  "contract_version": "1.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "clock_address",
      "funding_duration",
      "holder_address",
      "lp_token_denom",
      "note_address",
      "osmo_ibc_timeout",
      "osmo_outpost",
      "osmo_to_neutron_channel_id",
      "party_1_chain_info",
      "party_1_denom_info",
      "party_2_chain_info",
      "party_2_denom_info",
      "pool_id",
      "pool_price_config",
      "single_side_lp_limits"
    ],
    "properties": {
      "clock_address": {
        "type": "string"
      },
      "funding_duration": {
        "$ref": "#/definitions/Duration"
      },
      "holder_address": {
        "type": "string"
      },
      "lp_token_denom": {
        "type": "string"
      },
      "note_address": {
        "type": "string"
      },
      "osmo_ibc_timeout": {
        "$ref": "#/definitions/Uint64"
      },
      "osmo_outpost": {
        "type": "string"
      },
      "osmo_to_neutron_channel_id": {
        "type": "string"
      },
      "party_1_chain_info": {
        "$ref": "#/definitions/PartyChainInfo"
      },
      "party_1_denom_info": {
        "$ref": "#/definitions/PartyDenomInfo"
      },
      "party_2_chain_info": {
        "$ref": "#/definitions/PartyChainInfo"
      },
      "party_2_denom_info": {
        "$ref": "#/definitions/PartyDenomInfo"
      },
      "pool_id": {
        "$ref": "#/definitions/Uint64"
      },
      "pool_price_config": {
        "$ref": "#/definitions/PoolPriceConfig"
      },
      "single_side_lp_limits": {
        "$ref": "#/definitions/SingleSideLpLimits"
      },
      "slippage_tolerance": {
        "anyOf": [
          {
            "$ref": "#/definitions/Decimal"
          },
          {
            "type": "null"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Duration": {
        "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "height"
            ],
            "properties": {
              "height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Time in seconds",
            "type": "object",
            "required": [
              "time"
            ],
            "properties": {
              "time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ForwardMetadata": {
        "type": "object",
        "required": [
          "channel",
          "port",
          "receiver"
        ],
        "properties": {
          "channel": {
            "type": "string"
          },
          "port": {
            "type": "string"
          },
          "receiver": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "PartyChainInfo": {
        "type": "object",
        "required": [
          "ibc_timeout",
          "neutron_to_party_chain_channel",
          "party_chain_to_neutron_channel"
        ],
        "properties": {
          "ibc_timeout": {
            "$ref": "#/definitions/Uint64"
          },
          "inwards_pfm": {
            "description": "pfm configuration used to route funds from osmosis to local chain via origin chain",
            "anyOf": [
              {
                "$ref": "#/definitions/ForwardMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "neutron_to_party_chain_channel": {
            "description": "channel id to route funds from local chain to party chain",
            "type": "string"
          },
          "outwards_pfm": {
            "description": "pfm configuration used to route funds from local chain to osmosis via origin chain",
            "anyOf": [
              {
                "$ref": "#/definitions/ForwardMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "party_chain_to_neutron_channel": {
            "description": "channel id to route funds from party chain to local chain",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "PartyDenomInfo": {
        "type": "object",
        "required": [
          "local_denom",
          "osmosis_coin"
        ],
        "properties": {
          "local_denom": {
            "description": "ibc denom on liquid pooler chain",
            "type": "string"
          },
          "osmosis_coin": {
            "description": "coin as denominated on osmosis",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PoolPriceConfig": {
        "description": "config for the pool price expectations upon covenant instantiation",
        "type": "object",
        "required": [
          "acceptable_price_spread",
          "expected_spot_price"
        ],
        "properties": {
          "acceptable_price_spread": {
            "$ref": "#/definitions/Decimal"
          },
          "expected_spot_price": {
            "$ref": "#/definitions/Decimal"
          }
        },
        "additionalProperties": false
      },
      "SingleSideLpLimits": {
        "description": "single side lp limits define the highest amount (in `Uint128`) that we consider acceptable to provide single-sided. if asset balance exceeds these limits, double-sided liquidity should be provided.",
        "type": "object",
        "required": [
          "asset_a_limit",
          "asset_b_limit"
        ],
        "properties": {
          "asset_a_limit": {
            "$ref": "#/definitions/Uint128"
          },
          "asset_b_limit": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "callback"
        ],
        "properties": {
          "callback": {
            "$ref": "#/definitions/CallbackMessage"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Wakes the state machine up. The caller should check the sender of the tick is the clock if they'd like to pause when the clock does.",
        "type": "object",
        "required": [
          "tick"
        ],
        "properties": {
          "tick": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Tells the LPer to withdraw his position Should only be called by the holder of the covenant",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "properties": {
              "percentage": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Decimal"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "Attribute": {
        "description": "An key value pair that is used in the context of event attributes in logs",
        "type": "object",
        "required": [
          "key",
          "value"
        ],
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        }
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Callback": {
        "oneOf": [
          {
            "description": "Result of executing the requested query, or an error.\n\nresult[i] corresponds to the i'th query and contains the base64 encoded query response.",
            "type": "object",
            "required": [
              "query"
            ],
            "properties": {
              "query": {
                "$ref": "#/definitions/Result_of_Array_of_Binary_or_ErrorResponse"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Result of executing the requested messages, or an error.\n\n14/04/23: if a submessage errors the reply handler can see `codespace: wasm, code: 5`, but not the actual error. as a result, we can't return good errors for Execution and this error string will only tell you the error's codespace. for example, an out-of-gas error is code 11 and looks like `codespace: sdk, code: 11`.",
            "type": "object",
            "required": [
              "execute"
            ],
            "properties": {
              "execute": {
                "$ref": "#/definitions/Result_of_ExecutionResponse_or_String"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "An error occured that could not be recovered from. The only known way that this can occur is message handling running out of gas, in which case the error will be `codespace: sdk, code: 11`.\n\nThis error is not named becuase it could also occur due to a panic or unhandled error during message processing. We don't expect this to happen and have carefully written the code to avoid it.",
            "type": "object",
            "required": [
              "fatal_error"
            ],
            "properties": {
              "fatal_error": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "CallbackMessage": {
        "description": "Executed on the callback receiver upon message completion. When being executed, the message will be tagged with \"callback\":\n\n```json {\"callback\": { \"initiator\": ..., \"initiator_msg\": ..., \"result\": ..., }} ```",
        "type": "object",
        "required": [
          "initiator",
          "initiator_msg",
          "result"
        ],
        "properties": {
          "initiator": {
            "description": "Initaitor on the note chain.",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          },
          "initiator_msg": {
            "description": "Message sent by the initaitor. This _must_ be base64 encoded or execution will fail.",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          },
          "result": {
            "description": "Data from the host chain.",
            "allOf": [
              {
                "$ref": "#/definitions/Callback"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "ErrorResponse": {
        "type": "object",
        "required": [
          "error",
          "message_index"
        ],
        "properties": {
          "error": {
            "description": "The error that occured executing the message.",
            "type": "string"
          },
          "message_index": {
            "description": "The index of the first message who's execution failed.",
            "allOf": [
              {
                "$ref": "#/definitions/Uint64"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Event": {
        "description": "A full [*Cosmos SDK* event].\n\nThis version uses string attributes (similar to [*Cosmos SDK* StringEvent]), which then get magically converted to bytes for Tendermint somewhere between the Rust-Go interface, JSON deserialization and the `NewEvent` call in Cosmos SDK.\n\n[*Cosmos SDK* event]: https://docs.cosmos.network/main/learn/advanced/events [*Cosmos SDK* StringEvent]: https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/base/abci/v1beta1/abci.proto#L56-L70",
        "type": "object",
        "required": [
          "attributes",
          "type"
        ],
        "properties": {
          "attributes": {
            "description": "The attributes to be included in the event.\n\nYou can learn more about these from [*Cosmos SDK* docs].\n\n[*Cosmos SDK* docs]: https://docs.cosmos.network/main/learn/advanced/events",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Attribute"
            }
          },
          "type": {
            "description": "The event type. This is renamed to \"ty\" because \"type\" is reserved in Rust. This sucks, we know.",
            "type": "string"
          }
        }
      },
      "ExecutionResponse": {
        "type": "object",
        "required": [
          "executed_by",
          "result"
        ],
        "properties": {
          "executed_by": {
            "description": "The address on the remote chain that executed the messages.",
            "type": "string"
          },
          "result": {
            "description": "Index `i` corresponds to the result of executing the `i`th message.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/SubMsgResponse"
            }
          }
        },
        "additionalProperties": false
      },
      "Result_of_Array_of_Binary_or_ErrorResponse": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "Ok"
            ],
            "properties": {
              "Ok": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Binary"
                }
              }
            }
          },
          {
            "type": "object",
            "required": [
              "Err"
            ],
            "properties": {
              "Err": {
                "$ref": "#/definitions/ErrorResponse"
              }
            }
          }
        ]
      },
      "Result_of_ExecutionResponse_or_String": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "Ok"
            ],
            "properties": {
              "Ok": {
                "$ref": "#/definitions/ExecutionResponse"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "Err"
            ],
            "properties": {
              "Err": {
                "type": "string"
              }
            }
          }
        ]
      },
      "SubMsgResponse": {
        "description": "The information we get back from a successful sub message execution, with full Cosmos SDK events.",
        "type": "object",
        "required": [
          "events"
        ],
        "properties": {
          "data": {
            "anyOf": [
              {
                "$ref": "#/definitions/Binary"
              },
              {
                "type": "null"
              }
            ]
          },
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Event"
            }
          }
        }
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "contract_state"
        ],
        "properties": {
          "contract_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "holder_address"
        ],
        "properties": {
          "holder_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "liquidity_provision_config"
        ],
        "properties": {
          "liquidity_provision_config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "ibc_config"
        ],
        "properties": {
          "ibc_config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "proxy_address"
        ],
        "properties": {
          "proxy_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "callbacks"
        ],
        "properties": {
          "callbacks": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the associated clock address authorized to submit ticks",
        "type": "object",
        "required": [
          "clock_address"
        ],
        "properties": {
          "clock_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the address a contract expects to receive funds to",
        "type": "object",
        "required": [
          "deposit_address"
        ],
        "properties": {
          "deposit_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "clock_addr": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "holder_address": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "ibc_config": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/IbcConfig"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "lp_config": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/LiquidityProvisionConfig"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "note_address": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_code_id"
        ],
        "properties": {
          "update_code_id": {
            "type": "object",
            "properties": {
              "data": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Duration": {
        "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "height"
            ],
            "properties": {
              "height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Time in seconds",
            "type": "object",
            "required": [
              "time"
            ],
            "properties": {
              "time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ForwardMetadata": {
        "type": "object",
        "required": [
          "channel",
          "port",
          "receiver"
        ],
        "properties": {
          "channel": {
            "type": "string"
          },
          "port": {
            "type": "string"
          },
          "receiver": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "IbcConfig": {
        "type": "object",
        "required": [
          "osmo_ibc_timeout",
          "osmo_to_neutron_channel_id",
          "party_1_chain_info",
          "party_2_chain_info"
        ],
        "properties": {
          "osmo_ibc_timeout": {
            "$ref": "#/definitions/Uint64"
          },
          "osmo_to_neutron_channel_id": {
            "type": "string"
          },
          "party_1_chain_info": {
            "$ref": "#/definitions/PartyChainInfo"
          },
          "party_2_chain_info": {
            "$ref": "#/definitions/PartyChainInfo"
          }
        },
        "additionalProperties": false
      },
      "LiquidityProvisionConfig": {
        "type": "object",
        "required": [
          "funding_duration",
          "latest_balances",
          "lp_token_denom",
          "outpost",
          "party_1_denom_info",
          "party_2_denom_info",
          "pool_id",
          "pool_price_config",
          "single_side_lp_limits"
        ],
        "properties": {
          "funding_duration": {
            "$ref": "#/definitions/Duration"
          },
          "latest_balances": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/definitions/Coin"
            }
          },
          "lp_token_denom": {
            "type": "string"
          },
          "outpost": {
            "type": "string"
          },
          "party_1_denom_info": {
            "$ref": "#/definitions/PartyDenomInfo"
          },
          "party_2_denom_info": {
            "$ref": "#/definitions/PartyDenomInfo"
          },
          "pool_id": {
            "$ref": "#/definitions/Uint64"
          },
          "pool_price_config": {
            "$ref": "#/definitions/PoolPriceConfig"
          },
          "single_side_lp_limits": {
            "$ref": "#/definitions/SingleSideLpLimits"
          },
          "slippage_tolerance": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PartyChainInfo": {
        "type": "object",
        "required": [
          "ibc_timeout",
          "neutron_to_party_chain_channel",
          "party_chain_to_neutron_channel"
        ],
        "properties": {
          "ibc_timeout": {
            "$ref": "#/definitions/Uint64"
          },
          "inwards_pfm": {
            "description": "pfm configuration used to route funds from osmosis to local chain via origin chain",
            "anyOf": [
              {
                "$ref": "#/definitions/ForwardMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "neutron_to_party_chain_channel": {
            "description": "channel id to route funds from local chain to party chain",
            "type": "string"
          },
          "outwards_pfm": {
            "description": "pfm configuration used to route funds from local chain to osmosis via origin chain",
            "anyOf": [
              {
                "$ref": "#/definitions/ForwardMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "party_chain_to_neutron_channel": {
            "description": "channel id to route funds from party chain to local chain",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "PartyDenomInfo": {
        "type": "object",
        "required": [
          "local_denom",
          "osmosis_coin"
        ],
        "properties": {
          "local_denom": {
            "description": "ibc denom on liquid pooler chain",
            "type": "string"
          },
          "osmosis_coin": {
            "description": "coin as denominated on osmosis",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PoolPriceConfig": {
        "description": "config for the pool price expectations upon covenant instantiation",
        "type": "object",
        "required": [
          "acceptable_price_spread",
          "expected_spot_price"
        ],
        "properties": {
          "acceptable_price_spread": {
            "$ref": "#/definitions/Decimal"
          },
          "expected_spot_price": {
            "$ref": "#/definitions/Decimal"
          }
        },
        "additionalProperties": false
      },
      "SingleSideLpLimits": {
        "description": "single side lp limits define the highest amount (in `Uint128`) that we consider acceptable to provide single-sided. if asset balance exceeds these limits, double-sided liquidity should be provided.",
        "type": "object",
        "required": [
          "asset_a_limit",
          "asset_b_limit"
        ],
        "properties": {
          "asset_a_limit": {
            "$ref": "#/definitions/Uint128"
          },
          "asset_b_limit": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "sudo": null,
  "responses": {
    "callbacks": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "clock_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "contract_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractState",
      "description": "state of the LP state machine",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "instantiated",
            "proxy_created",
            "active"
          ]
        },
        {
          "type": "object",
          "required": [
            "proxy_funded"
          ],
          "properties": {
            "proxy_funded": {
              "type": "object",
              "required": [
                "funding_expiration"
              ],
              "properties": {
                "funding_expiration": {
                  "$ref": "#/definitions/Expiration"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "distributing"
          ],
          "properties": {
            "distributing": {
              "type": "object",
              "required": [
                "coins"
              ],
              "properties": {
                "coins": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "pending_withdrawal"
          ],
          "properties": {
            "pending_withdrawal": {
              "type": "object",
              "required": [
                "share"
              ],
              "properties": {
                "share": {
                  "$ref": "#/definitions/Decimal"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "deposit_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_String",
      "type": [
        "string",
        "null"
      ]
    },
    "holder_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "ibc_config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "IbcConfig",
      "type": "object",
      "required": [
        "osmo_ibc_timeout",
        "osmo_to_neutron_channel_id",
        "party_1_chain_info",
        "party_2_chain_info"
      ],
      "properties": {
        "osmo_ibc_timeout": {
          "$ref": "#/definitions/Uint64"
        },
        "osmo_to_neutron_channel_id": {
          "type": "string"
        },
        "party_1_chain_info": {
          "$ref": "#/definitions/PartyChainInfo"
        },
        "party_2_chain_info": {
          "$ref": "#/definitions/PartyChainInfo"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "ForwardMetadata": {
          "type": "object",
          "required": [
            "channel",
            "port",
            "receiver"
          ],
          "properties": {
            "channel": {
              "type": "string"
            },
            "port": {
              "type": "string"
            },
            "receiver": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "PartyChainInfo": {
          "type": "object",
          "required": [
            "ibc_timeout",
            "neutron_to_party_chain_channel",
            "party_chain_to_neutron_channel"
          ],
          "properties": {
            "ibc_timeout": {
              "$ref": "#/definitions/Uint64"
            },
            "inwards_pfm": {
              "description": "pfm configuration used to route funds from osmosis to local chain via origin chain",
              "anyOf": [
                {
                  "$ref": "#/definitions/ForwardMetadata"
                },
                {
                  "type": "null"
                }
              ]
            },
            "neutron_to_party_chain_channel": {
              "description": "channel id to route funds from local chain to party chain",
              "type": "string"
            },
            "outwards_pfm": {
              "description": "pfm configuration used to route funds from local chain to osmosis via origin chain",
              "anyOf": [
                {
                  "$ref": "#/definitions/ForwardMetadata"
                },
                {
                  "type": "null"
                }
              ]
            },
            "party_chain_to_neutron_channel": {
              "description": "channel id to route funds from party chain to local chain",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "liquidity_provision_config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LiquidityProvisionConfig",
      "type": "object",
      "required": [
        "funding_duration",
        "latest_balances",
        "lp_token_denom",
        "outpost",
        "party_1_denom_info",
        "party_2_denom_info",
        "pool_id",
        "pool_price_config",
        "single_side_lp_limits"
      ],
      "properties": {
        "funding_duration": {
          "$ref": "#/definitions/Duration"
        },
        "latest_balances": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Coin"
          }
        },
        "lp_token_denom": {
          "type": "string"
        },
        "outpost": {
          "type": "string"
        },
        "party_1_denom_info": {
          "$ref": "#/definitions/PartyDenomInfo"
        },
        "party_2_denom_info": {
          "$ref": "#/definitions/PartyDenomInfo"
        },
        "pool_id": {
          "$ref": "#/definitions/Uint64"
        },
        "pool_price_config": {
          "$ref": "#/definitions/PoolPriceConfig"
        },
        "single_side_lp_limits": {
          "$ref": "#/definitions/SingleSideLpLimits"
        },
        "slippage_tolerance": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Duration": {
          "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "height"
              ],
              "properties": {
                "height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Time in seconds",
              "type": "object",
              "required": [
                "time"
              ],
              "properties": {
                "time": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PartyDenomInfo": {
          "type": "object",
          "required": [
            "local_denom",
            "osmosis_coin"
          ],
          "properties": {
            "local_denom": {
              "description": "ibc denom on liquid pooler chain",
              "type": "string"
            },
            "osmosis_coin": {
              "description": "coin as denominated on osmosis",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PoolPriceConfig": {
          "description": "config for the pool price expectations upon covenant instantiation",
          "type": "object",
          "required": [
            "acceptable_price_spread",
            "expected_spot_price"
          ],
          "properties": {
            "acceptable_price_spread": {
              "$ref": "#/definitions/Decimal"
            },
            "expected_spot_price": {
              "$ref": "#/definitions/Decimal"
            }
          },
          "additionalProperties": false
        },
        "SingleSideLpLimits": {
          "description": "single side lp limits define the highest amount (in `Uint128`) that we consider acceptable to provide single-sided. if asset balance exceeds these limits, double-sided liquidity should be provided.",
          "type": "object",
          "required": [
            "asset_a_limit",
            "asset_b_limit"
          ],
          "properties": {
            "asset_a_limit": {
              "$ref": "#/definitions/Uint128"
            },
            "asset_b_limit": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "proxy_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_String",
      "type": [
        "string",
        "null"
      ]
    }
  }
}
