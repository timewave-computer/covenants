{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "InstantiateMsg",
  "type": "object",
  "required": [
    "contract_codes",
    "covenant_type",
    "deposit_deadline",
    "label",
    "liquid_pooler_config",
    "lockup_config",
    "operation_mode",
    "party_a_config",
    "party_a_share",
    "party_b_config",
    "party_b_share",
    "pool_price_config",
    "splits",
    "timeouts"
  ],
  "properties": {
    "clock_tick_max_gas": {
      "anyOf": [
        {
          "$ref": "#/definitions/Uint64"
        },
        {
          "type": "null"
        }
      ]
    },
    "contract_codes": {
      "$ref": "#/definitions/CovenantContractCodeIds"
    },
    "covenant_type": {
      "$ref": "#/definitions/CovenantType"
    },
    "deposit_deadline": {
      "$ref": "#/definitions/Expiration"
    },
    "emergency_committee": {
      "type": [
        "string",
        "null"
      ]
    },
    "fallback_address": {
      "type": [
        "string",
        "null"
      ]
    },
    "fallback_split": {
      "anyOf": [
        {
          "$ref": "#/definitions/SplitConfig"
        },
        {
          "type": "null"
        }
      ]
    },
    "label": {
      "type": "string"
    },
    "liquid_pooler_config": {
      "$ref": "#/definitions/LiquidPoolerConfig"
    },
    "lockup_config": {
      "$ref": "#/definitions/Expiration"
    },
    "operation_mode": {
      "$ref": "#/definitions/ContractOperationModeConfig"
    },
    "party_a_config": {
      "$ref": "#/definitions/CovenantPartyConfig"
    },
    "party_a_share": {
      "$ref": "#/definitions/Decimal"
    },
    "party_b_config": {
      "$ref": "#/definitions/CovenantPartyConfig"
    },
    "party_b_share": {
      "$ref": "#/definitions/Decimal"
    },
    "pool_price_config": {
      "$ref": "#/definitions/PoolPriceConfig"
    },
    "ragequit_config": {
      "anyOf": [
        {
          "$ref": "#/definitions/RagequitConfig"
        },
        {
          "type": "null"
        }
      ]
    },
    "splits": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/SplitConfig"
      }
    },
    "timeouts": {
      "$ref": "#/definitions/Timeouts"
    }
  },
  "additionalProperties": false,
  "definitions": {
    "AstroportLiquidPoolerConfig": {
      "type": "object",
      "required": [
        "asset_a_denom",
        "asset_b_denom",
        "pool_address",
        "pool_pair_type",
        "single_side_lp_limits"
      ],
      "properties": {
        "asset_a_denom": {
          "type": "string"
        },
        "asset_b_denom": {
          "type": "string"
        },
        "pool_address": {
          "type": "string"
        },
        "pool_pair_type": {
          "$ref": "#/definitions/PairType"
        },
        "single_side_lp_limits": {
          "$ref": "#/definitions/SingleSideLpLimits"
        }
      },
      "additionalProperties": false
    },
    "Coin": {
      "type": "object",
      "required": [
        "amount",
        "denom"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "denom": {
          "type": "string"
        }
      }
    },
    "ContractOperationModeConfig": {
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "permissionless"
          ]
        },
        {
          "type": "object",
          "required": [
            "permissioned"
          ],
          "properties": {
            "permissioned": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "CovenantContractCodeIds": {
      "type": "object",
      "required": [
        "clock_code",
        "holder_code",
        "ibc_forwarder_code",
        "interchain_router_code",
        "liquid_pooler_code",
        "native_router_code"
      ],
      "properties": {
        "clock_code": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "holder_code": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "ibc_forwarder_code": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "interchain_router_code": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "liquid_pooler_code": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "native_router_code": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "CovenantPartyConfig": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "interchain"
          ],
          "properties": {
            "interchain": {
              "$ref": "#/definitions/InterchainCovenantParty"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "native"
          ],
          "properties": {
            "native": {
              "$ref": "#/definitions/NativeCovenantParty"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "CovenantType": {
      "type": "string",
      "enum": [
        "share",
        "side"
      ]
    },
    "Decimal": {
      "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
      "type": "string"
    },
    "Duration": {
      "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "height"
          ],
          "properties": {
            "height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Time in seconds",
          "type": "object",
          "required": [
            "time"
          ],
          "properties": {
            "time": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Expiration": {
      "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
      "oneOf": [
        {
          "description": "AtHeight will expire when `env.block.height` >= height",
          "type": "object",
          "required": [
            "at_height"
          ],
          "properties": {
            "at_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "description": "AtTime will expire when `env.block.time` >= time",
          "type": "object",
          "required": [
            "at_time"
          ],
          "properties": {
            "at_time": {
              "$ref": "#/definitions/Timestamp"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Never will never expire. Used to express the empty variant",
          "type": "object",
          "required": [
            "never"
          ],
          "properties": {
            "never": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "ForwardMetadata": {
      "type": "object",
      "required": [
        "channel",
        "port",
        "receiver"
      ],
      "properties": {
        "channel": {
          "type": "string"
        },
        "port": {
          "type": "string"
        },
        "receiver": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "InterchainCovenantParty": {
      "type": "object",
      "required": [
        "addr",
        "contribution",
        "denom_to_pfm_map",
        "host_to_party_chain_channel_id",
        "ibc_transfer_timeout",
        "native_denom",
        "party_chain_connection_id",
        "party_receiver_addr",
        "party_to_host_chain_channel_id",
        "remote_chain_denom"
      ],
      "properties": {
        "addr": {
          "description": "authorized address of the party on neutron",
          "type": "string"
        },
        "contribution": {
          "description": "coin provided by the party on its native chain",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "denom_to_pfm_map": {
          "description": "configuration for unwinding the denoms via pfm",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/PacketForwardMiddlewareConfig"
          }
        },
        "fallback_address": {
          "description": "fallback refund address on the remote chain",
          "type": [
            "string",
            "null"
          ]
        },
        "host_to_party_chain_channel_id": {
          "description": "channel id from host chain to the party chain",
          "type": "string"
        },
        "ibc_transfer_timeout": {
          "description": "timeout in seconds",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "native_denom": {
          "description": "denom provided by the party on neutron",
          "type": "string"
        },
        "party_chain_connection_id": {
          "description": "connection id to the party chain",
          "type": "string"
        },
        "party_receiver_addr": {
          "description": "address of the receiver on destination chain",
          "type": "string"
        },
        "party_to_host_chain_channel_id": {
          "description": "channel id from party to host chain",
          "type": "string"
        },
        "remote_chain_denom": {
          "description": "denom provided by the party on its native chain",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "LiquidPoolerConfig": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "osmosis"
          ],
          "properties": {
            "osmosis": {
              "$ref": "#/definitions/OsmosisLiquidPoolerConfig"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "astroport"
          ],
          "properties": {
            "astroport": {
              "$ref": "#/definitions/AstroportLiquidPoolerConfig"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "NativeCovenantParty": {
      "type": "object",
      "required": [
        "addr",
        "contribution",
        "native_denom",
        "party_receiver_addr"
      ],
      "properties": {
        "addr": {
          "description": "authorized address of the party on neutron",
          "type": "string"
        },
        "contribution": {
          "description": "coin provided by the party on its native chain",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "native_denom": {
          "description": "denom provided by the party on neutron",
          "type": "string"
        },
        "party_receiver_addr": {
          "description": "address of the receiver on destination chain",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "OsmosisLiquidPoolerConfig": {
      "type": "object",
      "required": [
        "funding_duration",
        "lp_token_denom",
        "note_address",
        "osmo_ibc_timeout",
        "osmo_outpost",
        "osmo_to_neutron_channel_id",
        "party_1_chain_info",
        "party_1_denom_info",
        "party_2_chain_info",
        "party_2_denom_info",
        "pool_id",
        "single_side_lp_limits"
      ],
      "properties": {
        "funding_duration": {
          "$ref": "#/definitions/Duration"
        },
        "lp_token_denom": {
          "type": "string"
        },
        "note_address": {
          "type": "string"
        },
        "osmo_ibc_timeout": {
          "$ref": "#/definitions/Uint64"
        },
        "osmo_outpost": {
          "type": "string"
        },
        "osmo_to_neutron_channel_id": {
          "type": "string"
        },
        "party_1_chain_info": {
          "$ref": "#/definitions/PartyChainInfo"
        },
        "party_1_denom_info": {
          "$ref": "#/definitions/PartyDenomInfo"
        },
        "party_2_chain_info": {
          "$ref": "#/definitions/PartyChainInfo"
        },
        "party_2_denom_info": {
          "$ref": "#/definitions/PartyDenomInfo"
        },
        "pool_id": {
          "$ref": "#/definitions/Uint64"
        },
        "single_side_lp_limits": {
          "$ref": "#/definitions/SingleSideLpLimits"
        }
      },
      "additionalProperties": false
    },
    "PacketForwardMiddlewareConfig": {
      "type": "object",
      "required": [
        "hop_chain_receiver_address",
        "hop_to_destination_chain_channel_id",
        "local_to_hop_chain_channel_id"
      ],
      "properties": {
        "hop_chain_receiver_address": {
          "type": "string"
        },
        "hop_to_destination_chain_channel_id": {
          "type": "string"
        },
        "local_to_hop_chain_channel_id": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PairType": {
      "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
      "oneOf": [
        {
          "description": "XYK pair type",
          "type": "object",
          "required": [
            "xyk"
          ],
          "properties": {
            "xyk": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Stable pair type",
          "type": "object",
          "required": [
            "stable"
          ],
          "properties": {
            "stable": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Custom pair type",
          "type": "object",
          "required": [
            "custom"
          ],
          "properties": {
            "custom": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "PartyChainInfo": {
      "type": "object",
      "required": [
        "ibc_timeout",
        "neutron_to_party_chain_channel",
        "party_chain_to_neutron_channel"
      ],
      "properties": {
        "ibc_timeout": {
          "$ref": "#/definitions/Uint64"
        },
        "inwards_pfm": {
          "description": "pfm configuration used to route funds from osmosis to local chain via origin chain",
          "anyOf": [
            {
              "$ref": "#/definitions/ForwardMetadata"
            },
            {
              "type": "null"
            }
          ]
        },
        "neutron_to_party_chain_channel": {
          "description": "channel id to route funds from local chain to party chain",
          "type": "string"
        },
        "outwards_pfm": {
          "description": "pfm configuration used to route funds from local chain to osmosis via origin chain",
          "anyOf": [
            {
              "$ref": "#/definitions/ForwardMetadata"
            },
            {
              "type": "null"
            }
          ]
        },
        "party_chain_to_neutron_channel": {
          "description": "channel id to route funds from party chain to local chain",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PartyDenomInfo": {
      "type": "object",
      "required": [
        "local_denom",
        "osmosis_coin"
      ],
      "properties": {
        "local_denom": {
          "description": "ibc denom on liquid pooler chain",
          "type": "string"
        },
        "osmosis_coin": {
          "description": "coin as denominated on osmosis",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "PoolPriceConfig": {
      "description": "config for the pool price expectations upon covenant instantiation",
      "type": "object",
      "required": [
        "acceptable_price_spread",
        "expected_spot_price"
      ],
      "properties": {
        "acceptable_price_spread": {
          "$ref": "#/definitions/Decimal"
        },
        "expected_spot_price": {
          "$ref": "#/definitions/Decimal"
        }
      },
      "additionalProperties": false
    },
    "RagequitConfig": {
      "oneOf": [
        {
          "description": "ragequit is disabled",
          "type": "string",
          "enum": [
            "disabled"
          ]
        },
        {
          "description": "ragequit is enabled with `RagequitTerms`",
          "type": "object",
          "required": [
            "enabled"
          ],
          "properties": {
            "enabled": {
              "$ref": "#/definitions/RagequitTerms"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "RagequitState": {
      "type": "object",
      "required": [
        "coins",
        "rq_party"
      ],
      "properties": {
        "coins": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        },
        "rq_party": {
          "$ref": "#/definitions/TwoPartyPolCovenantParty"
        }
      },
      "additionalProperties": false
    },
    "RagequitTerms": {
      "type": "object",
      "required": [
        "penalty"
      ],
      "properties": {
        "penalty": {
          "description": "decimal based penalty to be applied on a party for initiating ragequit. Must be in the range of (0.00, 1.00). Also must not exceed either party allocations in raw values.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "state": {
          "description": "optional rq state. none indicates no ragequit. some holds the ragequit related config",
          "anyOf": [
            {
              "$ref": "#/definitions/RagequitState"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "SingleSideLpLimits": {
      "description": "single side lp limits define the highest amount (in `Uint128`) that we consider acceptable to provide single-sided. if asset balance exceeds these limits, double-sided liquidity should be provided.",
      "type": "object",
      "required": [
        "asset_a_limit",
        "asset_b_limit"
      ],
      "properties": {
        "asset_a_limit": {
          "$ref": "#/definitions/Uint128"
        },
        "asset_b_limit": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false
    },
    "SplitConfig": {
      "type": "object",
      "required": [
        "receivers"
      ],
      "properties": {
        "receivers": {
          "description": "map receiver address to its share of the split",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Decimal"
          }
        }
      },
      "additionalProperties": false
    },
    "Timeouts": {
      "type": "object",
      "required": [
        "ibc_transfer_timeout",
        "ica_timeout"
      ],
      "properties": {
        "ibc_transfer_timeout": {
          "description": "ibc transfer timeout in seconds",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "ica_timeout": {
          "description": "ica timeout in seconds",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Timestamp": {
      "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
      "allOf": [
        {
          "$ref": "#/definitions/Uint64"
        }
      ]
    },
    "TwoPartyPolCovenantParty": {
      "type": "object",
      "required": [
        "allocation",
        "contribution",
        "controller_addr",
        "host_addr",
        "router"
      ],
      "properties": {
        "allocation": {
          "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "contribution": {
          "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "controller_addr": {
          "description": "address of the party on the controller chain (final receiver)",
          "type": "string"
        },
        "host_addr": {
          "description": "neutron address authorized by the party to perform claims/ragequits",
          "type": "string"
        },
        "router": {
          "description": "address of the interchain router associated with this party",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "Uint64": {
      "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
      "type": "string"
    }
  }
}
