{
  "contract_name": "valence-covenant-two-party-pol",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "contract_codes",
      "covenant_type",
      "deposit_deadline",
      "label",
      "liquid_pooler_config",
      "lockup_config",
      "operation_mode",
      "party_a_config",
      "party_a_share",
      "party_b_config",
      "party_b_share",
      "pool_price_config",
      "splits",
      "timeouts"
    ],
    "properties": {
      "clock_tick_max_gas": {
        "anyOf": [
          {
            "$ref": "#/definitions/Uint64"
          },
          {
            "type": "null"
          }
        ]
      },
      "contract_codes": {
        "$ref": "#/definitions/CovenantContractCodeIds"
      },
      "covenant_type": {
        "$ref": "#/definitions/CovenantType"
      },
      "deposit_deadline": {
        "$ref": "#/definitions/Expiration"
      },
      "emergency_committee": {
        "type": [
          "string",
          "null"
        ]
      },
      "fallback_address": {
        "type": [
          "string",
          "null"
        ]
      },
      "fallback_split": {
        "anyOf": [
          {
            "$ref": "#/definitions/SplitConfig"
          },
          {
            "type": "null"
          }
        ]
      },
      "label": {
        "type": "string"
      },
      "liquid_pooler_config": {
        "$ref": "#/definitions/LiquidPoolerConfig"
      },
      "lockup_config": {
        "$ref": "#/definitions/Expiration"
      },
      "operation_mode": {
        "$ref": "#/definitions/ContractOperationModeConfig"
      },
      "party_a_config": {
        "$ref": "#/definitions/CovenantPartyConfig"
      },
      "party_a_share": {
        "$ref": "#/definitions/Decimal"
      },
      "party_b_config": {
        "$ref": "#/definitions/CovenantPartyConfig"
      },
      "party_b_share": {
        "$ref": "#/definitions/Decimal"
      },
      "pool_price_config": {
        "$ref": "#/definitions/PoolPriceConfig"
      },
      "ragequit_config": {
        "anyOf": [
          {
            "$ref": "#/definitions/RagequitConfig"
          },
          {
            "type": "null"
          }
        ]
      },
      "splits": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/definitions/SplitConfig"
        }
      },
      "timeouts": {
        "$ref": "#/definitions/Timeouts"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "AstroportLiquidPoolerConfig": {
        "type": "object",
        "required": [
          "asset_a_denom",
          "asset_b_denom",
          "pool_address",
          "pool_pair_type",
          "single_side_lp_limits"
        ],
        "properties": {
          "asset_a_denom": {
            "type": "string"
          },
          "asset_b_denom": {
            "type": "string"
          },
          "pool_address": {
            "type": "string"
          },
          "pool_pair_type": {
            "$ref": "#/definitions/PairType"
          },
          "single_side_lp_limits": {
            "$ref": "#/definitions/SingleSideLpLimits"
          }
        },
        "additionalProperties": false
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "ContractOperationModeConfig": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "permissionless"
            ]
          },
          {
            "type": "object",
            "required": [
              "permissioned"
            ],
            "properties": {
              "permissioned": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "CovenantContractCodeIds": {
        "type": "object",
        "required": [
          "clock_code",
          "holder_code",
          "ibc_forwarder_code",
          "interchain_router_code",
          "liquid_pooler_code",
          "native_router_code"
        ],
        "properties": {
          "clock_code": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "holder_code": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "ibc_forwarder_code": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "interchain_router_code": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "liquid_pooler_code": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "native_router_code": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "CovenantPartyConfig": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "interchain"
            ],
            "properties": {
              "interchain": {
                "$ref": "#/definitions/InterchainCovenantParty"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "native"
            ],
            "properties": {
              "native": {
                "$ref": "#/definitions/NativeCovenantParty"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "CovenantType": {
        "type": "string",
        "enum": [
          "share",
          "side"
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Duration": {
        "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "height"
            ],
            "properties": {
              "height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Time in seconds",
            "type": "object",
            "required": [
              "time"
            ],
            "properties": {
              "time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ForwardMetadata": {
        "type": "object",
        "required": [
          "channel",
          "port",
          "receiver"
        ],
        "properties": {
          "channel": {
            "type": "string"
          },
          "port": {
            "type": "string"
          },
          "receiver": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "InterchainCovenantParty": {
        "type": "object",
        "required": [
          "addr",
          "contribution",
          "denom_to_pfm_map",
          "host_to_party_chain_channel_id",
          "ibc_transfer_timeout",
          "native_denom",
          "party_chain_connection_id",
          "party_receiver_addr",
          "party_to_host_chain_channel_id",
          "remote_chain_denom"
        ],
        "properties": {
          "addr": {
            "description": "authorized address of the party on neutron",
            "type": "string"
          },
          "contribution": {
            "description": "coin provided by the party on its native chain",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "denom_to_pfm_map": {
            "description": "configuration for unwinding the denoms via pfm",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/definitions/PacketForwardMiddlewareConfig"
            }
          },
          "fallback_address": {
            "description": "fallback refund address on the remote chain",
            "type": [
              "string",
              "null"
            ]
          },
          "host_to_party_chain_channel_id": {
            "description": "channel id from host chain to the party chain",
            "type": "string"
          },
          "ibc_transfer_timeout": {
            "description": "timeout in seconds",
            "allOf": [
              {
                "$ref": "#/definitions/Uint64"
              }
            ]
          },
          "native_denom": {
            "description": "denom provided by the party on neutron",
            "type": "string"
          },
          "party_chain_connection_id": {
            "description": "connection id to the party chain",
            "type": "string"
          },
          "party_receiver_addr": {
            "description": "address of the receiver on destination chain",
            "type": "string"
          },
          "party_to_host_chain_channel_id": {
            "description": "channel id from party to host chain",
            "type": "string"
          },
          "remote_chain_denom": {
            "description": "denom provided by the party on its native chain",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "LiquidPoolerConfig": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "osmosis"
            ],
            "properties": {
              "osmosis": {
                "$ref": "#/definitions/OsmosisLiquidPoolerConfig"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "astroport"
            ],
            "properties": {
              "astroport": {
                "$ref": "#/definitions/AstroportLiquidPoolerConfig"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "NativeCovenantParty": {
        "type": "object",
        "required": [
          "addr",
          "contribution",
          "native_denom",
          "party_receiver_addr"
        ],
        "properties": {
          "addr": {
            "description": "authorized address of the party on neutron",
            "type": "string"
          },
          "contribution": {
            "description": "coin provided by the party on its native chain",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "native_denom": {
            "description": "denom provided by the party on neutron",
            "type": "string"
          },
          "party_receiver_addr": {
            "description": "address of the receiver on destination chain",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "OsmosisLiquidPoolerConfig": {
        "type": "object",
        "required": [
          "funding_duration",
          "lp_token_denom",
          "note_address",
          "osmo_ibc_timeout",
          "osmo_outpost",
          "osmo_to_neutron_channel_id",
          "party_1_chain_info",
          "party_1_denom_info",
          "party_2_chain_info",
          "party_2_denom_info",
          "pool_id",
          "single_side_lp_limits"
        ],
        "properties": {
          "funding_duration": {
            "$ref": "#/definitions/Duration"
          },
          "lp_token_denom": {
            "type": "string"
          },
          "note_address": {
            "type": "string"
          },
          "osmo_ibc_timeout": {
            "$ref": "#/definitions/Uint64"
          },
          "osmo_outpost": {
            "type": "string"
          },
          "osmo_to_neutron_channel_id": {
            "type": "string"
          },
          "party_1_chain_info": {
            "$ref": "#/definitions/PartyChainInfo"
          },
          "party_1_denom_info": {
            "$ref": "#/definitions/PartyDenomInfo"
          },
          "party_2_chain_info": {
            "$ref": "#/definitions/PartyChainInfo"
          },
          "party_2_denom_info": {
            "$ref": "#/definitions/PartyDenomInfo"
          },
          "pool_id": {
            "$ref": "#/definitions/Uint64"
          },
          "single_side_lp_limits": {
            "$ref": "#/definitions/SingleSideLpLimits"
          }
        },
        "additionalProperties": false
      },
      "PacketForwardMiddlewareConfig": {
        "type": "object",
        "required": [
          "hop_chain_receiver_address",
          "hop_to_destination_chain_channel_id",
          "local_to_hop_chain_channel_id"
        ],
        "properties": {
          "hop_chain_receiver_address": {
            "type": "string"
          },
          "hop_to_destination_chain_channel_id": {
            "type": "string"
          },
          "local_to_hop_chain_channel_id": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "PairType": {
        "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
        "oneOf": [
          {
            "description": "XYK pair type",
            "type": "object",
            "required": [
              "xyk"
            ],
            "properties": {
              "xyk": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Stable pair type",
            "type": "object",
            "required": [
              "stable"
            ],
            "properties": {
              "stable": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Custom pair type",
            "type": "object",
            "required": [
              "custom"
            ],
            "properties": {
              "custom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "PartyChainInfo": {
        "type": "object",
        "required": [
          "ibc_timeout",
          "neutron_to_party_chain_channel",
          "party_chain_to_neutron_channel"
        ],
        "properties": {
          "ibc_timeout": {
            "$ref": "#/definitions/Uint64"
          },
          "inwards_pfm": {
            "description": "pfm configuration used to route funds from osmosis to local chain via origin chain",
            "anyOf": [
              {
                "$ref": "#/definitions/ForwardMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "neutron_to_party_chain_channel": {
            "description": "channel id to route funds from local chain to party chain",
            "type": "string"
          },
          "outwards_pfm": {
            "description": "pfm configuration used to route funds from local chain to osmosis via origin chain",
            "anyOf": [
              {
                "$ref": "#/definitions/ForwardMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "party_chain_to_neutron_channel": {
            "description": "channel id to route funds from party chain to local chain",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "PartyDenomInfo": {
        "type": "object",
        "required": [
          "local_denom",
          "osmosis_coin"
        ],
        "properties": {
          "local_denom": {
            "description": "ibc denom on liquid pooler chain",
            "type": "string"
          },
          "osmosis_coin": {
            "description": "coin as denominated on osmosis",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PoolPriceConfig": {
        "description": "config for the pool price expectations upon covenant instantiation",
        "type": "object",
        "required": [
          "acceptable_price_spread",
          "expected_spot_price"
        ],
        "properties": {
          "acceptable_price_spread": {
            "$ref": "#/definitions/Decimal"
          },
          "expected_spot_price": {
            "$ref": "#/definitions/Decimal"
          }
        },
        "additionalProperties": false
      },
      "RagequitConfig": {
        "oneOf": [
          {
            "description": "ragequit is disabled",
            "type": "string",
            "enum": [
              "disabled"
            ]
          },
          {
            "description": "ragequit is enabled with `RagequitTerms`",
            "type": "object",
            "required": [
              "enabled"
            ],
            "properties": {
              "enabled": {
                "$ref": "#/definitions/RagequitTerms"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "RagequitState": {
        "type": "object",
        "required": [
          "coins",
          "rq_party"
        ],
        "properties": {
          "coins": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "rq_party": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          }
        },
        "additionalProperties": false
      },
      "RagequitTerms": {
        "type": "object",
        "required": [
          "penalty"
        ],
        "properties": {
          "penalty": {
            "description": "decimal based penalty to be applied on a party for initiating ragequit. Must be in the range of (0.00, 1.00). Also must not exceed either party allocations in raw values.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "state": {
            "description": "optional rq state. none indicates no ragequit. some holds the ragequit related config",
            "anyOf": [
              {
                "$ref": "#/definitions/RagequitState"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "SingleSideLpLimits": {
        "description": "single side lp limits define the highest amount (in `Uint128`) that we consider acceptable to provide single-sided. if asset balance exceeds these limits, double-sided liquidity should be provided.",
        "type": "object",
        "required": [
          "asset_a_limit",
          "asset_b_limit"
        ],
        "properties": {
          "asset_a_limit": {
            "$ref": "#/definitions/Uint128"
          },
          "asset_b_limit": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "SplitConfig": {
        "type": "object",
        "required": [
          "receivers"
        ],
        "properties": {
          "receivers": {
            "description": "map receiver address to its share of the split",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/definitions/Decimal"
            }
          }
        },
        "additionalProperties": false
      },
      "Timeouts": {
        "type": "object",
        "required": [
          "ibc_transfer_timeout",
          "ica_timeout"
        ],
        "properties": {
          "ibc_transfer_timeout": {
            "description": "ibc transfer timeout in seconds",
            "allOf": [
              {
                "$ref": "#/definitions/Uint64"
              }
            ]
          },
          "ica_timeout": {
            "description": "ica timeout in seconds",
            "allOf": [
              {
                "$ref": "#/definitions/Uint64"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "TwoPartyPolCovenantParty": {
        "type": "object",
        "required": [
          "allocation",
          "contribution",
          "controller_addr",
          "host_addr",
          "router"
        ],
        "properties": {
          "allocation": {
            "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "contribution": {
            "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "controller_addr": {
            "description": "address of the party on the controller chain (final receiver)",
            "type": "string"
          },
          "host_addr": {
            "description": "neutron address authorized by the party to perform claims/ragequits",
            "type": "string"
          },
          "router": {
            "description": "address of the interchain router associated with this party",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "type": "string",
    "enum": []
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "clock_address"
        ],
        "properties": {
          "clock_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "holder_address"
        ],
        "properties": {
          "holder_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "ibc_forwarder_address"
        ],
        "properties": {
          "ibc_forwarder_address": {
            "type": "object",
            "required": [
              "party"
            ],
            "properties": {
              "party": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "interchain_router_address"
        ],
        "properties": {
          "interchain_router_address": {
            "type": "object",
            "required": [
              "party"
            ],
            "properties": {
              "party": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "liquid_pooler_address"
        ],
        "properties": {
          "liquid_pooler_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "party_deposit_address"
        ],
        "properties": {
          "party_deposit_address": {
            "type": "object",
            "required": [
              "party"
            ],
            "properties": {
              "party": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "contract_codes"
        ],
        "properties": {
          "contract_codes": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "update_covenant"
        ],
        "properties": {
          "update_covenant": {
            "type": "object",
            "properties": {
              "clock": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/MigrateMsg"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "codes": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/CovenantContractCodes"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "holder": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/MigrateMsg2"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "liquid_pooler": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/LiquidPoolerMigrateMsg"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "party_a_forwarder": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/MigrateMsg7"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "party_a_router": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/RouterMigrateMsg"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "party_b_forwarder": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/MigrateMsg7"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "party_b_router": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/RouterMigrateMsg"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_code_id"
        ],
        "properties": {
          "update_code_id": {
            "type": "object",
            "properties": {
              "data": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AssetData": {
        "description": "holds the both asset denoms relevant for providing liquidity",
        "type": "object",
        "required": [
          "asset_a_denom",
          "asset_b_denom"
        ],
        "properties": {
          "asset_a_denom": {
            "type": "string"
          },
          "asset_b_denom": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "ContractOperationModeConfig": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "permissionless"
            ]
          },
          {
            "type": "object",
            "required": [
              "permissioned"
            ],
            "properties": {
              "permissioned": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "CovenantContractCodes": {
        "type": "object",
        "required": [
          "clock",
          "holder",
          "liquid_pooler",
          "party_a_forwarder",
          "party_a_router",
          "party_b_forwarder",
          "party_b_router"
        ],
        "properties": {
          "clock": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "holder": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "liquid_pooler": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "party_a_forwarder": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "party_a_router": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "party_b_forwarder": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "party_b_router": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "CovenantType": {
        "type": "string",
        "enum": [
          "share",
          "side"
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "DecimalRange": {
        "type": "object",
        "required": [
          "max",
          "min"
        ],
        "properties": {
          "max": {
            "$ref": "#/definitions/Decimal"
          },
          "min": {
            "$ref": "#/definitions/Decimal"
          }
        },
        "additionalProperties": false
      },
      "DestinationConfig": {
        "type": "object",
        "required": [
          "denom_to_pfm_map",
          "destination_receiver_addr",
          "ibc_transfer_timeout",
          "local_to_destination_chain_channel_id"
        ],
        "properties": {
          "denom_to_pfm_map": {
            "description": "pfm configurations for denoms",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/definitions/PacketForwardMiddlewareConfig"
            }
          },
          "destination_receiver_addr": {
            "description": "address of the receiver on destination chain",
            "type": "string"
          },
          "ibc_transfer_timeout": {
            "description": "timeout in seconds",
            "allOf": [
              {
                "$ref": "#/definitions/Uint64"
              }
            ]
          },
          "local_to_destination_chain_channel_id": {
            "description": "channel id of the destination chain",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Duration": {
        "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "height"
            ],
            "properties": {
              "height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Time in seconds",
            "type": "object",
            "required": [
              "time"
            ],
            "properties": {
              "time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "FallbackAddressUpdateConfig": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "explicit_address"
            ],
            "properties": {
              "explicit_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "disable"
            ],
            "properties": {
              "disable": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ForwardMetadata": {
        "type": "object",
        "required": [
          "channel",
          "port",
          "receiver"
        ],
        "properties": {
          "channel": {
            "type": "string"
          },
          "port": {
            "type": "string"
          },
          "receiver": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "IbcConfig": {
        "type": "object",
        "required": [
          "osmo_ibc_timeout",
          "osmo_to_neutron_channel_id",
          "party_1_chain_info",
          "party_2_chain_info"
        ],
        "properties": {
          "osmo_ibc_timeout": {
            "$ref": "#/definitions/Uint64"
          },
          "osmo_to_neutron_channel_id": {
            "type": "string"
          },
          "party_1_chain_info": {
            "$ref": "#/definitions/PartyChainInfo"
          },
          "party_2_chain_info": {
            "$ref": "#/definitions/PartyChainInfo"
          }
        },
        "additionalProperties": false
      },
      "LiquidPoolerMigrateMsg": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "osmosis"
            ],
            "properties": {
              "osmosis": {
                "$ref": "#/definitions/MigrateMsg3"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "astroport"
            ],
            "properties": {
              "astroport": {
                "$ref": "#/definitions/MigrateMsg4"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "LiquidityProvisionConfig": {
        "type": "object",
        "required": [
          "funding_duration",
          "latest_balances",
          "lp_token_denom",
          "outpost",
          "party_1_denom_info",
          "party_2_denom_info",
          "pool_id",
          "pool_price_config",
          "single_side_lp_limits"
        ],
        "properties": {
          "funding_duration": {
            "$ref": "#/definitions/Duration"
          },
          "latest_balances": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/definitions/Coin"
            }
          },
          "lp_token_denom": {
            "type": "string"
          },
          "outpost": {
            "type": "string"
          },
          "party_1_denom_info": {
            "$ref": "#/definitions/PartyDenomInfo"
          },
          "party_2_denom_info": {
            "$ref": "#/definitions/PartyDenomInfo"
          },
          "pool_id": {
            "$ref": "#/definitions/Uint64"
          },
          "pool_price_config": {
            "$ref": "#/definitions/PoolPriceConfig"
          },
          "single_side_lp_limits": {
            "$ref": "#/definitions/SingleSideLpLimits"
          },
          "slippage_tolerance": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "LpConfig": {
        "type": "object",
        "required": [
          "asset_data",
          "expected_pool_ratio_range",
          "pair_type",
          "pool_address",
          "single_side_lp_limits"
        ],
        "properties": {
          "asset_data": {
            "description": "denoms of both parties",
            "allOf": [
              {
                "$ref": "#/definitions/AssetData"
              }
            ]
          },
          "expected_pool_ratio_range": {
            "description": "expected price range",
            "allOf": [
              {
                "$ref": "#/definitions/DecimalRange"
              }
            ]
          },
          "pair_type": {
            "description": "pair type specified in the covenant",
            "allOf": [
              {
                "$ref": "#/definitions/PairType"
              }
            ]
          },
          "pool_address": {
            "description": "address of the liquidity pool we plan to enter",
            "allOf": [
              {
                "$ref": "#/definitions/Addr"
              }
            ]
          },
          "single_side_lp_limits": {
            "description": "amounts of both tokens we consider ok to single-side lp",
            "allOf": [
              {
                "$ref": "#/definitions/SingleSideLpLimits"
              }
            ]
          },
          "slippage_tolerance": {
            "description": "slippage tolerance parameter for liquidity provisioning",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "MigrateMsg": {
        "oneOf": [
          {
            "description": "Pauses the clock. No `ExecuteMsg` messages will be executable until the clock is unpaused. Callable only if the clock is unpaused.",
            "type": "object",
            "required": [
              "pause"
            ],
            "properties": {
              "pause": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Unpauses the clock. Callable only if the clock is paused.",
            "type": "object",
            "required": [
              "unpause"
            ],
            "properties": {
              "unpause": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Updates the max gas allowed to be consumed by a tick. This should be no larger than 100_000 less the block max gas so as to save enough gas to process the tick's error.",
            "type": "object",
            "required": [
              "update_tick_max_gas"
            ],
            "properties": {
              "update_tick_max_gas": {
                "type": "object",
                "required": [
                  "new_value"
                ],
                "properties": {
                  "new_value": {
                    "$ref": "#/definitions/Uint64"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_code_id"
            ],
            "properties": {
              "update_code_id": {
                "type": "object",
                "properties": {
                  "data": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "manage_whitelist"
            ],
            "properties": {
              "manage_whitelist": {
                "type": "object",
                "properties": {
                  "add": {
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "type": "string"
                    }
                  },
                  "remove": {
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "MigrateMsg2": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "update_config"
            ],
            "properties": {
              "update_config": {
                "type": "object",
                "properties": {
                  "covenant_config": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/TwoPartyPolCovenantConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "denom_splits": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "additionalProperties": {
                      "$ref": "#/definitions/SplitConfig"
                    }
                  },
                  "deposit_deadline": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "emergency_committee": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "fallback_split": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/SplitConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "lockup_config": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "next_contract": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "op_mode": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/ContractOperationModeConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "ragequit_config": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/RagequitConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_code_id"
            ],
            "properties": {
              "update_code_id": {
                "type": "object",
                "properties": {
                  "data": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "MigrateMsg3": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "update_config"
            ],
            "properties": {
              "update_config": {
                "type": "object",
                "properties": {
                  "holder_address": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "ibc_config": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/IbcConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "lp_config": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/LiquidityProvisionConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "note_address": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "op_mode": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/ContractOperationModeConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_code_id"
            ],
            "properties": {
              "update_code_id": {
                "type": "object",
                "properties": {
                  "data": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "MigrateMsg4": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "update_config"
            ],
            "properties": {
              "update_config": {
                "type": "object",
                "properties": {
                  "holder_address": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "lp_config": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/LpConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "op_mode": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/ContractOperationModeConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_code_id"
            ],
            "properties": {
              "update_code_id": {
                "type": "object",
                "properties": {
                  "data": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "MigrateMsg5": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "update_config"
            ],
            "properties": {
              "update_config": {
                "type": "object",
                "properties": {
                  "destination_config": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/DestinationConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "op_mode": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/ContractOperationModeConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "target_denoms": {
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_code_id"
            ],
            "properties": {
              "update_code_id": {
                "type": "object",
                "properties": {
                  "data": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "MigrateMsg6": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "update_config"
            ],
            "properties": {
              "update_config": {
                "type": "object",
                "properties": {
                  "op_mode": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/ContractOperationModeConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "receiver_address": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "target_denoms": {
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_code_id"
            ],
            "properties": {
              "update_code_id": {
                "type": "object",
                "properties": {
                  "data": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "MigrateMsg7": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "update_config"
            ],
            "properties": {
              "update_config": {
                "type": "object",
                "properties": {
                  "fallback_address": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/FallbackAddressUpdateConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "next_contract": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "op_mode": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/ContractOperationModeConfig"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "remote_chain_info": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/RemoteChainInfo"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "transfer_amount": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Uint128"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_code_id"
            ],
            "properties": {
              "update_code_id": {
                "type": "object",
                "properties": {
                  "data": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "PacketForwardMiddlewareConfig": {
        "type": "object",
        "required": [
          "hop_chain_receiver_address",
          "hop_to_destination_chain_channel_id",
          "local_to_hop_chain_channel_id"
        ],
        "properties": {
          "hop_chain_receiver_address": {
            "type": "string"
          },
          "hop_to_destination_chain_channel_id": {
            "type": "string"
          },
          "local_to_hop_chain_channel_id": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "PairType": {
        "description": "This enum describes available pair types. ## Available pool types ``` # use astroport::factory::PairType::{Custom, Stable, Xyk}; Xyk {}; Stable {}; Custom(String::from(\"Custom\")); ```",
        "oneOf": [
          {
            "description": "XYK pair type",
            "type": "object",
            "required": [
              "xyk"
            ],
            "properties": {
              "xyk": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Stable pair type",
            "type": "object",
            "required": [
              "stable"
            ],
            "properties": {
              "stable": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Custom pair type",
            "type": "object",
            "required": [
              "custom"
            ],
            "properties": {
              "custom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "PartyChainInfo": {
        "type": "object",
        "required": [
          "ibc_timeout",
          "neutron_to_party_chain_channel",
          "party_chain_to_neutron_channel"
        ],
        "properties": {
          "ibc_timeout": {
            "$ref": "#/definitions/Uint64"
          },
          "inwards_pfm": {
            "description": "pfm configuration used to route funds from osmosis to local chain via origin chain",
            "anyOf": [
              {
                "$ref": "#/definitions/ForwardMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "neutron_to_party_chain_channel": {
            "description": "channel id to route funds from local chain to party chain",
            "type": "string"
          },
          "outwards_pfm": {
            "description": "pfm configuration used to route funds from local chain to osmosis via origin chain",
            "anyOf": [
              {
                "$ref": "#/definitions/ForwardMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "party_chain_to_neutron_channel": {
            "description": "channel id to route funds from party chain to local chain",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "PartyDenomInfo": {
        "type": "object",
        "required": [
          "local_denom",
          "osmosis_coin"
        ],
        "properties": {
          "local_denom": {
            "description": "ibc denom on liquid pooler chain",
            "type": "string"
          },
          "osmosis_coin": {
            "description": "coin as denominated on osmosis",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "PoolPriceConfig": {
        "description": "config for the pool price expectations upon covenant instantiation",
        "type": "object",
        "required": [
          "acceptable_price_spread",
          "expected_spot_price"
        ],
        "properties": {
          "acceptable_price_spread": {
            "$ref": "#/definitions/Decimal"
          },
          "expected_spot_price": {
            "$ref": "#/definitions/Decimal"
          }
        },
        "additionalProperties": false
      },
      "RagequitConfig": {
        "oneOf": [
          {
            "description": "ragequit is disabled",
            "type": "string",
            "enum": [
              "disabled"
            ]
          },
          {
            "description": "ragequit is enabled with `RagequitTerms`",
            "type": "object",
            "required": [
              "enabled"
            ],
            "properties": {
              "enabled": {
                "$ref": "#/definitions/RagequitTerms"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "RagequitState": {
        "type": "object",
        "required": [
          "coins",
          "rq_party"
        ],
        "properties": {
          "coins": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "rq_party": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          }
        },
        "additionalProperties": false
      },
      "RagequitTerms": {
        "type": "object",
        "required": [
          "penalty"
        ],
        "properties": {
          "penalty": {
            "description": "decimal based penalty to be applied on a party for initiating ragequit. Must be in the range of (0.00, 1.00). Also must not exceed either party allocations in raw values.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "state": {
            "description": "optional rq state. none indicates no ragequit. some holds the ragequit related config",
            "anyOf": [
              {
                "$ref": "#/definitions/RagequitState"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "RemoteChainInfo": {
        "type": "object",
        "required": [
          "channel_id",
          "connection_id",
          "denom",
          "ibc_transfer_timeout",
          "ica_timeout"
        ],
        "properties": {
          "channel_id": {
            "type": "string"
          },
          "connection_id": {
            "description": "connection id from neutron to the remote chain on which we wish to open an ICA",
            "type": "string"
          },
          "denom": {
            "type": "string"
          },
          "ibc_transfer_timeout": {
            "$ref": "#/definitions/Uint64"
          },
          "ica_timeout": {
            "$ref": "#/definitions/Uint64"
          }
        },
        "additionalProperties": false
      },
      "RouterMigrateMsg": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "interchain"
            ],
            "properties": {
              "interchain": {
                "$ref": "#/definitions/MigrateMsg5"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "native"
            ],
            "properties": {
              "native": {
                "$ref": "#/definitions/MigrateMsg6"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SingleSideLpLimits": {
        "description": "single side lp limits define the highest amount (in `Uint128`) that we consider acceptable to provide single-sided. if asset balance exceeds these limits, double-sided liquidity should be provided.",
        "type": "object",
        "required": [
          "asset_a_limit",
          "asset_b_limit"
        ],
        "properties": {
          "asset_a_limit": {
            "$ref": "#/definitions/Uint128"
          },
          "asset_b_limit": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "SplitConfig": {
        "type": "object",
        "required": [
          "receivers"
        ],
        "properties": {
          "receivers": {
            "description": "map receiver address to its share of the split",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/definitions/Decimal"
            }
          }
        },
        "additionalProperties": false
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "TwoPartyPolCovenantConfig": {
        "type": "object",
        "required": [
          "covenant_type",
          "party_a",
          "party_b"
        ],
        "properties": {
          "covenant_type": {
            "$ref": "#/definitions/CovenantType"
          },
          "party_a": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          },
          "party_b": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          }
        },
        "additionalProperties": false
      },
      "TwoPartyPolCovenantParty": {
        "type": "object",
        "required": [
          "allocation",
          "contribution",
          "controller_addr",
          "host_addr",
          "router"
        ],
        "properties": {
          "allocation": {
            "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "contribution": {
            "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "controller_addr": {
            "description": "address of the party on the controller chain (final receiver)",
            "type": "string"
          },
          "host_addr": {
            "description": "neutron address authorized by the party to perform claims/ragequits",
            "type": "string"
          },
          "router": {
            "description": "address of the interchain router associated with this party",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "sudo": null,
  "responses": {
    "clock_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "contract_codes": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CovenantContractCodes",
      "type": "object",
      "required": [
        "clock",
        "holder",
        "liquid_pooler",
        "party_a_forwarder",
        "party_a_router",
        "party_b_forwarder",
        "party_b_router"
      ],
      "properties": {
        "clock": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "holder": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "liquid_pooler": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "party_a_forwarder": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "party_a_router": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "party_b_forwarder": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "party_b_router": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "holder_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "ibc_forwarder_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "interchain_router_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "liquid_pooler_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "party_deposit_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    }
  }
}
