{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "RagequitConfig",
  "oneOf": [
    {
      "description": "ragequit is disabled",
      "type": "string",
      "enum": [
        "disabled"
      ]
    },
    {
      "description": "ragequit is enabled with `RagequitTerms`",
      "type": "object",
      "required": [
        "enabled"
      ],
      "properties": {
        "enabled": {
          "$ref": "#/definitions/RagequitTerms"
        }
      },
      "additionalProperties": false
    }
  ],
  "definitions": {
    "Coin": {
      "type": "object",
      "required": [
        "amount",
        "denom"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "denom": {
          "type": "string"
        }
      }
    },
    "Decimal": {
      "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
      "type": "string"
    },
    "RagequitState": {
      "type": "object",
      "required": [
        "coins",
        "rq_party"
      ],
      "properties": {
        "coins": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        },
        "rq_party": {
          "$ref": "#/definitions/TwoPartyPolCovenantParty"
        }
      },
      "additionalProperties": false
    },
    "RagequitTerms": {
      "type": "object",
      "required": [
        "penalty"
      ],
      "properties": {
        "penalty": {
          "description": "decimal based penalty to be applied on a party for initiating ragequit. Must be in the range of (0.00, 1.00). Also must not exceed either party allocations in raw values.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "state": {
          "description": "optional rq state. none indicates no ragequit. some holds the ragequit related config",
          "anyOf": [
            {
              "$ref": "#/definitions/RagequitState"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "TwoPartyPolCovenantParty": {
      "type": "object",
      "required": [
        "allocation",
        "contribution",
        "controller_addr",
        "host_addr",
        "router"
      ],
      "properties": {
        "allocation": {
          "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "contribution": {
          "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "controller_addr": {
          "description": "address of the party on the controller chain (final receiver)",
          "type": "string"
        },
        "host_addr": {
          "description": "neutron address authorized by the party to perform claims/ragequits",
          "type": "string"
        },
        "router": {
          "description": "address of the interchain router associated with this party",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    }
  }
}
