{
  "contract_name": "valence-two-party-pol-holder",
  "contract_version": "1.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "clock_address",
      "covenant_config",
      "deposit_deadline",
      "lockup_config",
      "next_contract",
      "ragequit_config",
      "splits"
    ],
    "properties": {
      "clock_address": {
        "description": "address of authorized clock",
        "type": "string"
      },
      "covenant_config": {
        "description": "config describing the covenant dynamics",
        "allOf": [
          {
            "$ref": "#/definitions/TwoPartyPolCovenantConfig"
          }
        ]
      },
      "deposit_deadline": {
        "description": "deadline for both parties to deposit their funds",
        "allOf": [
          {
            "$ref": "#/definitions/Expiration"
          }
        ]
      },
      "emergency_committee_addr": {
        "description": "address of the emergency committee",
        "type": [
          "string",
          "null"
        ]
      },
      "fallback_split": {
        "description": "a split for all denoms that are not covered in the regular `splits` list",
        "anyOf": [
          {
            "$ref": "#/definitions/SplitConfig"
          },
          {
            "type": "null"
          }
        ]
      },
      "lockup_config": {
        "description": "config describing the agreed upon duration of POL",
        "allOf": [
          {
            "$ref": "#/definitions/Expiration"
          }
        ]
      },
      "next_contract": {
        "description": "liquid pooler address",
        "type": "string"
      },
      "ragequit_config": {
        "description": "config describing early exit dynamics",
        "allOf": [
          {
            "$ref": "#/definitions/RagequitConfig"
          }
        ]
      },
      "splits": {
        "description": "mapping of denoms to their splits",
        "type": "object",
        "additionalProperties": {
          "$ref": "#/definitions/SplitConfig"
        }
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "CovenantType": {
        "type": "string",
        "enum": [
          "share",
          "side"
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "RagequitConfig": {
        "oneOf": [
          {
            "description": "ragequit is disabled",
            "type": "string",
            "enum": [
              "disabled"
            ]
          },
          {
            "description": "ragequit is enabled with `RagequitTerms`",
            "type": "object",
            "required": [
              "enabled"
            ],
            "properties": {
              "enabled": {
                "$ref": "#/definitions/RagequitTerms"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "RagequitState": {
        "type": "object",
        "required": [
          "coins",
          "rq_party"
        ],
        "properties": {
          "coins": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "rq_party": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          }
        },
        "additionalProperties": false
      },
      "RagequitTerms": {
        "type": "object",
        "required": [
          "penalty"
        ],
        "properties": {
          "penalty": {
            "description": "decimal based penalty to be applied on a party for initiating ragequit. Must be in the range of (0.00, 1.00). Also must not exceed either party allocations in raw values.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "state": {
            "description": "optional rq state. none indicates no ragequit. some holds the ragequit related config",
            "anyOf": [
              {
                "$ref": "#/definitions/RagequitState"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "SplitConfig": {
        "type": "object",
        "required": [
          "receivers"
        ],
        "properties": {
          "receivers": {
            "description": "map receiver address to its share of the split",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/definitions/Decimal"
            }
          }
        },
        "additionalProperties": false
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "TwoPartyPolCovenantConfig": {
        "type": "object",
        "required": [
          "covenant_type",
          "party_a",
          "party_b"
        ],
        "properties": {
          "covenant_type": {
            "$ref": "#/definitions/CovenantType"
          },
          "party_a": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          },
          "party_b": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          }
        },
        "additionalProperties": false
      },
      "TwoPartyPolCovenantParty": {
        "type": "object",
        "required": [
          "allocation",
          "contribution",
          "controller_addr",
          "host_addr",
          "router"
        ],
        "properties": {
          "allocation": {
            "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "contribution": {
            "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "controller_addr": {
            "description": "address of the party on the controller chain (final receiver)",
            "type": "string"
          },
          "host_addr": {
            "description": "neutron address authorized by the party to perform claims/ragequits",
            "type": "string"
          },
          "router": {
            "description": "address of the interchain router associated with this party",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "initiate the ragequit",
        "type": "object",
        "required": [
          "ragequit"
        ],
        "properties": {
          "ragequit": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "withdraw the liquidity party is entitled to",
        "type": "object",
        "required": [
          "claim"
        ],
        "properties": {
          "claim": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "distribute any unspecified denoms",
        "type": "object",
        "required": [
          "distribute_fallback_split"
        ],
        "properties": {
          "distribute_fallback_split": {
            "type": "object",
            "required": [
              "denoms"
            ],
            "properties": {
              "denoms": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Wakes the state machine up. The caller should check the sender of the tick is the clock if they'd like to pause when the clock does.",
        "type": "object",
        "required": [
          "tick"
        ],
        "properties": {
          "tick": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "After LPer finished withdrawing from LP, it sends the funds to the holder and the holder distributes them based on its logic Should only be called by the LPer of the covenant",
        "type": "object",
        "required": [
          "distribute"
        ],
        "properties": {
          "distribute": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "This message is sent in case we do an IBC withdraw The withdraw can fail in async way, in case that happens we want the holder to be notified on that. In case of astroport, the withdraww + distribution is atomic, so nothing to worry there But in case  of osmosis, the withdraw is async, so the \"claim\" will successful happen, while the withdraw can fail, in case the withdraw fails here, we execute this message on the holder",
        "type": "object",
        "required": [
          "withdraw_failed"
        ],
        "properties": {
          "withdraw_failed": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows for the emergency committee to withdraw the funds on case of an emergency",
        "type": "object",
        "required": [
          "emergency_withdraw"
        ],
        "properties": {
          "emergency_withdraw": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "contract_state"
        ],
        "properties": {
          "contract_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "ragequit_config"
        ],
        "properties": {
          "ragequit_config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "lockup_config"
        ],
        "properties": {
          "lockup_config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "config_party_a"
        ],
        "properties": {
          "config_party_a": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "config_party_b"
        ],
        "properties": {
          "config_party_b": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "deposit_deadline"
        ],
        "properties": {
          "deposit_deadline": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "denom_splits"
        ],
        "properties": {
          "denom_splits": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "emergency_committee"
        ],
        "properties": {
          "emergency_committee": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the associated clock address authorized to submit ticks",
        "type": "object",
        "required": [
          "clock_address"
        ],
        "properties": {
          "clock_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the associated remote chain information",
        "type": "object",
        "required": [
          "next_contract"
        ],
        "properties": {
          "next_contract": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns the address a contract expects to receive funds to",
        "type": "object",
        "required": [
          "deposit_address"
        ],
        "properties": {
          "deposit_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "clock_addr": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "covenant_config": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/TwoPartyPolCovenantConfig"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "denom_splits": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/definitions/SplitConfig"
                }
              },
              "deposit_deadline": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "emergency_committee": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "fallback_split": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/SplitConfig"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "lockup_config": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "next_contract": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "ragequit_config": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/RagequitConfig"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_code_id"
        ],
        "properties": {
          "update_code_id": {
            "type": "object",
            "properties": {
              "data": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "CovenantType": {
        "type": "string",
        "enum": [
          "share",
          "side"
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "RagequitConfig": {
        "oneOf": [
          {
            "description": "ragequit is disabled",
            "type": "string",
            "enum": [
              "disabled"
            ]
          },
          {
            "description": "ragequit is enabled with `RagequitTerms`",
            "type": "object",
            "required": [
              "enabled"
            ],
            "properties": {
              "enabled": {
                "$ref": "#/definitions/RagequitTerms"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "RagequitState": {
        "type": "object",
        "required": [
          "coins",
          "rq_party"
        ],
        "properties": {
          "coins": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "rq_party": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          }
        },
        "additionalProperties": false
      },
      "RagequitTerms": {
        "type": "object",
        "required": [
          "penalty"
        ],
        "properties": {
          "penalty": {
            "description": "decimal based penalty to be applied on a party for initiating ragequit. Must be in the range of (0.00, 1.00). Also must not exceed either party allocations in raw values.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "state": {
            "description": "optional rq state. none indicates no ragequit. some holds the ragequit related config",
            "anyOf": [
              {
                "$ref": "#/definitions/RagequitState"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "SplitConfig": {
        "type": "object",
        "required": [
          "receivers"
        ],
        "properties": {
          "receivers": {
            "description": "map receiver address to its share of the split",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/definitions/Decimal"
            }
          }
        },
        "additionalProperties": false
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "TwoPartyPolCovenantConfig": {
        "type": "object",
        "required": [
          "covenant_type",
          "party_a",
          "party_b"
        ],
        "properties": {
          "covenant_type": {
            "$ref": "#/definitions/CovenantType"
          },
          "party_a": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          },
          "party_b": {
            "$ref": "#/definitions/TwoPartyPolCovenantParty"
          }
        },
        "additionalProperties": false
      },
      "TwoPartyPolCovenantParty": {
        "type": "object",
        "required": [
          "allocation",
          "contribution",
          "controller_addr",
          "host_addr",
          "router"
        ],
        "properties": {
          "allocation": {
            "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "contribution": {
            "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "controller_addr": {
            "description": "address of the party on the controller chain (final receiver)",
            "type": "string"
          },
          "host_addr": {
            "description": "neutron address authorized by the party to perform claims/ragequits",
            "type": "string"
          },
          "router": {
            "description": "address of the interchain router associated with this party",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "sudo": null,
  "responses": {
    "clock_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TwoPartyPolCovenantConfig",
      "type": "object",
      "required": [
        "covenant_type",
        "party_a",
        "party_b"
      ],
      "properties": {
        "covenant_type": {
          "$ref": "#/definitions/CovenantType"
        },
        "party_a": {
          "$ref": "#/definitions/TwoPartyPolCovenantParty"
        },
        "party_b": {
          "$ref": "#/definitions/TwoPartyPolCovenantParty"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "CovenantType": {
          "type": "string",
          "enum": [
            "share",
            "side"
          ]
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "TwoPartyPolCovenantParty": {
          "type": "object",
          "required": [
            "allocation",
            "contribution",
            "controller_addr",
            "host_addr",
            "router"
          ],
          "properties": {
            "allocation": {
              "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "contribution": {
              "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "controller_addr": {
              "description": "address of the party on the controller chain (final receiver)",
              "type": "string"
            },
            "host_addr": {
              "description": "neutron address authorized by the party to perform claims/ragequits",
              "type": "string"
            },
            "router": {
              "description": "address of the interchain router associated with this party",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "config_party_a": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TwoPartyPolCovenantParty",
      "type": "object",
      "required": [
        "allocation",
        "contribution",
        "controller_addr",
        "host_addr",
        "router"
      ],
      "properties": {
        "allocation": {
          "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "contribution": {
          "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "controller_addr": {
          "description": "address of the party on the controller chain (final receiver)",
          "type": "string"
        },
        "host_addr": {
          "description": "neutron address authorized by the party to perform claims/ragequits",
          "type": "string"
        },
        "router": {
          "description": "address of the interchain router associated with this party",
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "config_party_b": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TwoPartyPolCovenantParty",
      "type": "object",
      "required": [
        "allocation",
        "contribution",
        "controller_addr",
        "host_addr",
        "router"
      ],
      "properties": {
        "allocation": {
          "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "contribution": {
          "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "controller_addr": {
          "description": "address of the party on the controller chain (final receiver)",
          "type": "string"
        },
        "host_addr": {
          "description": "neutron address authorized by the party to perform claims/ragequits",
          "type": "string"
        },
        "router": {
          "description": "address of the interchain router associated with this party",
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "contract_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractState",
      "oneOf": [
        {
          "description": "contract is instantiated and awaiting for deposits from both parties involved",
          "type": "string",
          "enum": [
            "instantiated"
          ]
        },
        {
          "description": "funds have been forwarded to the LP module. from the perspective of this contract that indicates an active LP position.",
          "type": "string",
          "enum": [
            "active"
          ]
        },
        {
          "description": "one of the parties have initiated ragequit. the remaining counterparty with an active position is free to exit at any time.",
          "type": "string",
          "enum": [
            "ragequit"
          ]
        },
        {
          "description": "covenant has reached its expiration date.",
          "type": "string",
          "enum": [
            "expired"
          ]
        },
        {
          "description": "underlying funds have been withdrawn.",
          "type": "string",
          "enum": [
            "complete"
          ]
        }
      ]
    },
    "denom_splits": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DenomSplits",
      "type": "object",
      "required": [
        "explicit_splits"
      ],
      "properties": {
        "explicit_splits": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/SplitConfig"
          }
        },
        "fallback_split": {
          "anyOf": [
            {
              "$ref": "#/definitions/SplitConfig"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "SplitConfig": {
          "type": "object",
          "required": [
            "receivers"
          ],
          "properties": {
            "receivers": {
              "description": "map receiver address to its share of the split",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Decimal"
              }
            }
          },
          "additionalProperties": false
        }
      }
    },
    "deposit_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_String",
      "type": [
        "string",
        "null"
      ]
    },
    "deposit_deadline": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Expiration",
      "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
      "oneOf": [
        {
          "description": "AtHeight will expire when `env.block.height` >= height",
          "type": "object",
          "required": [
            "at_height"
          ],
          "properties": {
            "at_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "description": "AtTime will expire when `env.block.time` >= time",
          "type": "object",
          "required": [
            "at_time"
          ],
          "properties": {
            "at_time": {
              "$ref": "#/definitions/Timestamp"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Never will never expire. Used to express the empty variant",
          "type": "object",
          "required": [
            "never"
          ],
          "properties": {
            "never": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "emergency_committee": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "lockup_config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Expiration",
      "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
      "oneOf": [
        {
          "description": "AtHeight will expire when `env.block.height` >= height",
          "type": "object",
          "required": [
            "at_height"
          ],
          "properties": {
            "at_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "description": "AtTime will expire when `env.block.time` >= time",
          "type": "object",
          "required": [
            "at_time"
          ],
          "properties": {
            "at_time": {
              "$ref": "#/definitions/Timestamp"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Never will never expire. Used to express the empty variant",
          "type": "object",
          "required": [
            "never"
          ],
          "properties": {
            "never": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "next_contract": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_String",
      "type": [
        "string",
        "null"
      ]
    },
    "ragequit_config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RagequitConfig",
      "oneOf": [
        {
          "description": "ragequit is disabled",
          "type": "string",
          "enum": [
            "disabled"
          ]
        },
        {
          "description": "ragequit is enabled with `RagequitTerms`",
          "type": "object",
          "required": [
            "enabled"
          ],
          "properties": {
            "enabled": {
              "$ref": "#/definitions/RagequitTerms"
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "RagequitState": {
          "type": "object",
          "required": [
            "coins",
            "rq_party"
          ],
          "properties": {
            "coins": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Coin"
              }
            },
            "rq_party": {
              "$ref": "#/definitions/TwoPartyPolCovenantParty"
            }
          },
          "additionalProperties": false
        },
        "RagequitTerms": {
          "type": "object",
          "required": [
            "penalty"
          ],
          "properties": {
            "penalty": {
              "description": "decimal based penalty to be applied on a party for initiating ragequit. Must be in the range of (0.00, 1.00). Also must not exceed either party allocations in raw values.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "state": {
              "description": "optional rq state. none indicates no ragequit. some holds the ragequit related config",
              "anyOf": [
                {
                  "$ref": "#/definitions/RagequitState"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "TwoPartyPolCovenantParty": {
          "type": "object",
          "required": [
            "allocation",
            "contribution",
            "controller_addr",
            "host_addr",
            "router"
          ],
          "properties": {
            "allocation": {
              "description": "fraction of the entire LP position owned by the party. upon exiting it becomes 0.00. if counterparty exits, this would become 1.00, meaning that this party owns the entire position managed by the covenant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "contribution": {
              "description": "the `denom` and `amount` (`Uint128`) to be contributed by the party",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "controller_addr": {
              "description": "address of the party on the controller chain (final receiver)",
              "type": "string"
            },
            "host_addr": {
              "description": "neutron address authorized by the party to perform claims/ragequits",
              "type": "string"
            },
            "router": {
              "description": "address of the interchain router associated with this party",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
